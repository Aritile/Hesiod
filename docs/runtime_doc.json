{
  "Abs": {
    "category": "Math/Base",
    "description": "Apply an absolute function to every values.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Reference value for the zero-equivalent value of the absolute value.",
        "key": "vshift",
        "type": "Float"
      }
    ],
    "snapshot": "Abs.png"
  },
  "AbsSmooth": {
    "category": "Math/Base",
    "description": "Apply a smooth absolute value function to every values. The smooth absolute operator computes the absolute value of an input while providing a smooth transition around zero, ensuring continuity and smoothness in the output.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Smoothing intensity.",
        "key": "mu",
        "type": "Float"
      },
      {
        "description": "Reference value for the zero-equivalent value of the absolute value.",
        "key": "vshift",
        "type": "Float"
      }
    ],
    "snapshot": "AbsSmooth.png"
  },
  "AccumulationCurvature": {
    "category": "Features/Landform",
    "description": "AccumulationCurvature is a specific type of curvature reflecting how the shape of the heightmap influences the accumulation of water. Positive accumulation curvature indicates converging flow, where water tends to accumulate and concentrate, often leading to the formation of channels or gullies. Negative accumulation curvature suggests diverging flow, where water is dispersed over a broader area, which is typical of ridges or hilltops.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Accumulation curvature.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "AccumulationCurvature.png"
  },
  "Blend": {
    "category": "Operator/Blend",
    "description": "The Blend operator takes two input heightmaps.",
    "inputs": [
      {
        "caption": "input 1",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "input 2",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Blending method. Available values: add, exclusion, gradients, maximum, maximum_smooth, minimum, minimum_smooth, multiply, multiply_add, negate, overlay, soft, substract.",
        "key": "blending_method",
        "type": "Enumeration"
      },
      {
        "description": "Smoothing intensity (if any).",
        "key": "k",
        "type": "Float"
      },
      {
        "description": "Filter radius with respect to the domain size (if any).",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "Blend.png"
  },
  "Bump": {
    "category": "Primitive/Function",
    "description": "Bump generates a smooth transitions between zero-valued boundaries and the center of the domain.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Bump heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Center x coordinate.",
        "key": "center.x",
        "type": "Float"
      },
      {
        "description": "Center y coordinate.",
        "key": "center.y",
        "type": "Float"
      },
      {
        "description": "Shape control parameter.",
        "key": "gain",
        "type": "Float"
      }
    ],
    "snapshot": "Bump.png"
  },
  "Caldera": {
    "category": "Primitive/Geological",
    "description": "Caldera generates a volcanic caldera landscape.",
    "inputs": [
      {
        "caption": "dr",
        "description": "Displacement with respect to the domain size (normal direction).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Caldera heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Center x coordinate.",
        "key": "center.x",
        "type": "Float"
      },
      {
        "description": "Center y coordinate.",
        "key": "center.y",
        "type": "Float"
      },
      {
        "description": "Noise amplitude for the radial displacement.",
        "key": "noise_r_amp",
        "type": "Float"
      },
      {
        "description": "Noise amplitude for the vertical displacement.",
        "key": "noise_ratio_z",
        "type": "Float"
      },
      {
        "description": "Crater radius.",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Crater inner lip half-width.",
        "key": "sigma_inner",
        "type": "Float"
      },
      {
        "description": "Crater outer lip half-width.",
        "key": "sigma_outer",
        "type": "Float"
      },
      {
        "description": "Crater bottom elevation.",
        "key": "z_bottom",
        "type": "Float"
      }
    ],
    "snapshot": "Caldera.png"
  },
  "Clamp": {
    "category": "Filter/Range",
    "description": "Clamp restrict a value within a specified range. Essentially, it ensures that a value does not exceed a defined upper limit or fall below a defined lower limit.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Clamped heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Clamping range.",
        "key": "clamp",
        "type": "Value range"
      },
      {
        "description": "Upper bound smoothing intensity.",
        "key": "k_max",
        "type": "Float"
      },
      {
        "description": "Lower bound smoothing intensity.",
        "key": "k_min",
        "type": "Float"
      },
      {
        "description": "Activate smooth clamping for the upper bound.",
        "key": "smooth_max",
        "type": "Bool"
      },
      {
        "description": "Activate smooth clamping for the lower bound.",
        "key": "smooth_min",
        "type": "Bool"
      }
    ],
    "snapshot": "Clamp.png"
  },
  "Closing": {
    "category": "Operator/Morphology",
    "description": "Closing is a combination of dilation followed by erosion. It is primarily used for closing small holes or gaps in objects. Use Cases: Hole filling: Closing can fill small holes or gaps in objects, making them more solid and complete. Connecting broken objects: Closing can help connect broken segments or regions in an image, making objects more continuous.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Dilated heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "Closing.png"
  },
  "Cloud": {
    "category": "Geometry/Cloud",
    "description": "Set of points.",
    "inputs": [],
    "outputs": [
      {
        "caption": "cloud",
        "description": "Set of points (x, y) and elevations z.",
        "type": "Cloud"
      }
    ],
    "parameters": [
      {
        "description": "Cloud data.",
        "key": "cloud",
        "type": "HighMap Cloud Object"
      }
    ],
    "snapshot": "Cloud.png"
  },
  "CloudLattice": {
    "category": "Geometry/Cloud",
    "description": "Generate a grid lattice set of points.",
    "inputs": [],
    "outputs": [
      {
        "caption": "cloud",
        "description": "Set of points (x, y) and elevations z.",
        "type": "Cloud"
      }
    ],
    "parameters": [
      {
        "description": "Point spacing in x and y directions.",
        "key": "delta",
        "type": "Wavenumber"
      },
      {
        "description": "Point jittering (noise) in x and y directions.",
        "key": "jitter_ratio",
        "type": "Wavenumber"
      },
      {
        "description": "Random seed number",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Point offset in x and y directions for every two lines or columns.",
        "key": "stagger_ratio",
        "type": "Wavenumber"
      }
    ],
    "snapshot": "CloudLattice.png"
  },
  "CloudMerge": {
    "category": "Geometry/Cloud",
    "description": "CloudMerge merges two clouds into a single one.",
    "inputs": [
      {
        "caption": "cloud1",
        "description": "Input cloud.",
        "type": "Cloud"
      },
      {
        "caption": "cloud2",
        "description": "Input cloud.",
        "type": "Cloud"
      }
    ],
    "outputs": [
      {
        "caption": "cloud",
        "description": "Merged cloud.",
        "type": "Cloud"
      }
    ],
    "parameters": [],
    "snapshot": "CloudMerge.png"
  },
  "CloudRandom": {
    "category": "Geometry/Cloud",
    "description": "Random set of points.",
    "inputs": [],
    "outputs": [
      {
        "caption": "cloud",
        "description": "Set of points (x, y) and elevations z.",
        "type": "Cloud"
      }
    ],
    "parameters": [
      {
        "description": "Number of points.",
        "key": "npoints",
        "type": "Integer"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "CloudRandom.png"
  },
  "CloudRemapValues": {
    "category": "Geometry/Cloud",
    "description": "CloudRemapValues remap the range of the cloud point values.",
    "inputs": [
      {
        "caption": "cloud",
        "description": "Input cloud.",
        "type": "Cloud"
      }
    ],
    "outputs": [
      {
        "caption": "cloud",
        "description": "Output cloud.",
        "type": "Cloud"
      }
    ],
    "parameters": [],
    "snapshot": "CloudRemapValues.png"
  },
  "CloudSDF": {
    "category": "Geometry/Cloud",
    "description": "CloudSDF evaluates the signed distance function of a set of points. It assigns a signed distance value to every point in space.",
    "inputs": [
      {
        "caption": "cloud",
        "description": "Input cloud.",
        "type": "Cloud"
      }
    ],
    "outputs": [
      {
        "caption": "sdf",
        "description": "Signed distance as an heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "CloudSDF.png"
  },
  "CloudToArrayInterp": {
    "category": "Primitive/Authoring",
    "description": "CloudToArrayInterp generates a smooth and continuous 2D elevation map from a set of scattered points using Delaunay linear interpolation.",
    "inputs": [
      {
        "caption": "cloud",
        "description": "Set of points (x, y) and elevations z.",
        "type": "Cloud"
      },
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "heightmap",
        "description": "Interpolated heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "CloudToArrayInterp.png"
  },
  "CloudToPath": {
    "category": "Converter",
    "description": "CloudToPath convert a Cloud to a Path.",
    "inputs": [
      {
        "caption": "cloud",
        "description": "Input cloud.",
        "type": "Cloud"
      }
    ],
    "outputs": [
      {
        "caption": "path",
        "description": "Output path.",
        "type": "Path"
      }
    ],
    "parameters": [
      {
        "description": "Decides whether the path is open and closed on itself.",
        "key": "closed",
        "type": "Bool"
      },
      {
        "description": "Decides whether the path points are reordered using a nearest neighbor search.",
        "key": "reorder_nns",
        "type": "Bool"
      }
    ],
    "snapshot": "CloudToPath.png"
  },
  "ColorizeCmap": {
    "category": "Texture",
    "description": "ColorizeCmap generates a texture based on colormaps to assign colors to data values.",
    "inputs": [
      {
        "caption": "level",
        "description": "Data values for color selection.",
        "type": "HeightMap"
      },
      {
        "caption": "alpha",
        "description": "Texture alpha map.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "texture",
        "description": "Texture (RGBA).",
        "type": "HeightMapRGBA"
      }
    ],
    "parameters": [
      {
        "description": "Clamp to [0, 1] to input alpha map.",
        "key": "clamp_alpha",
        "type": "Bool"
      },
      {
        "description": "Color mapping selection. Available values: adrceist, aneprosi, angghore, anilyftp, anthatly, ascaired, aselllfa, aveflili, blesiblh, blywixps, boustous, byapsahi, bychpmem, cecelldf, ceitwope, cesintho, coffrrea, ctthaton, dffygutu, dfvieryo, drctheet, drfftiee, dwinthed, eafbissf, eporepop, ewntherb, feredwnt, fffadeng, ffwatsan, fleoreha, fromsesh, ftapewon, gsercrts, haviarof, hendesth, imongsir, indthsad, inosulul, intoshee, iresetyl, isungror, itteloud, ivericed, lereitth, majucent, mburmats, mearesit, meppremb, mofhewon, nalymeve, noasbian, ofasnfoi, ofoffrmp, oleonowh, onaaloni, ontomayw, outtsthe, owwheplu, pechrede, pellaine, piventon, plfgsthi, rbonblnc, rredtthe, sarermat, seclytme, sfreante, sheshesa, sinabuse, sindwirt, snotheca, ssemeool, suttlseb, taldidov, teasitis, teieebit, tharetwe, thengici, therinon, thesihas, thisathe, thoeftsw, tiamatsp, tinusprr, tiomithe, tnymeewh, tonndind, trererat, ttyaveft, tyfotinm, ucerecen, ucererds, upeesith, usoerlea, veranghh, verdeisu, wadsuthe, wbegweic, whetitat, whhorefr, wminamin, wsatavin, yierahon.",
        "key": "colormap",
        "type": "Enumeration"
      },
      {
        "description": "Reverse the input alpha map.",
        "key": "reverse_alpha",
        "type": "Bool"
      },
      {
        "description": "Reverse the colormap range.",
        "key": "reverse_colormap",
        "type": "Bool"
      }
    ],
    "snapshot": "ColorizeCmap.png"
  },
  "ColorizeGradient": {
    "category": "Texture",
    "description": "ColorizeGradient generates a texture based on colormaps to assign colors to data values.",
    "inputs": [
      {
        "caption": "level",
        "description": "Data values for color selection.",
        "type": "HeightMap"
      },
      {
        "caption": "alpha",
        "description": "Texture alpha map.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "texture",
        "description": "Texture (RGBA).",
        "type": "HeightMapRGBA"
      }
    ],
    "parameters": [
      {
        "description": "Clamp to [0, 1] to input alpha map.",
        "key": "clamp_alpha",
        "type": "Bool"
      },
      {
        "description": "Colormap as a manually defined color gradient.",
        "key": "gradient",
        "type": "Color gradient"
      },
      {
        "description": "Reverse the input alpha map.",
        "key": "reverse_alpha",
        "type": "Bool"
      },
      {
        "description": "Reverse the colormap range.",
        "key": "reverse_colormap",
        "type": "Bool"
      }
    ],
    "snapshot": "ColorizeGradient.png"
  },
  "ColorizeSolid": {
    "category": "Texture",
    "description": "ColorizeSolid generates an uniform texture based on an input color.",
    "inputs": [],
    "outputs": [
      {
        "caption": "texture",
        "description": "Texture (RGBA).",
        "type": "HeightMapRGBA"
      }
    ],
    "parameters": [
      {
        "description": "Transparency as a scalar value",
        "key": "alpha",
        "type": "Float"
      },
      {
        "description": "Solid color.",
        "key": "color",
        "type": "Color"
      }
    ],
    "snapshot": "ColorizeSolid.png"
  },
  "CombineMask": {
    "category": "Mask",
    "description": "CombineMask performs basic logical operations on a pair of heightmaps (assuming they are used as masks).",
    "inputs": [
      {
        "caption": "input 1",
        "description": "Input mask.",
        "type": "HeightMap"
      },
      {
        "caption": "input 2",
        "description": "Input mask.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Combined mask.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Combining method. Available values: exclusion, intersection, union.",
        "key": "method",
        "type": "Enumeration"
      }
    ],
    "snapshot": "CombineMask.png"
  },
  "Comment": {
    "category": "Comment",
    "description": "Comment node is a passive node holding a comment text.",
    "inputs": [],
    "outputs": [],
    "parameters": [
      {
        "description": "Text comment.",
        "key": "comment",
        "type": "String"
      }
    ],
    "snapshot": "Comment.png"
  },
  "ConvolveSVD": {
    "category": "Math/Convolution",
    "description": "ConvolveSVD performs convolution using a Singular Value Decomposition (SVD) of the kernel to accelerate the process.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "kernel",
        "description": "Convolution kernel.",
        "type": "Kernel"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Rank of the singular value decomposition.",
        "key": "rank",
        "type": "Integer"
      }
    ],
    "snapshot": "ConvolveSVD.png"
  },
  "Cos": {
    "category": "Math/Base",
    "description": "Apply a cosine function to every values.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Frequency.",
        "key": "frequency",
        "type": "Float"
      },
      {
        "description": "Phase shift.",
        "key": "phase_shift",
        "type": "Float"
      }
    ],
    "snapshot": "Cos.png"
  },
  "Crater": {
    "category": "Primitive/Geological",
    "description": "Crater generates a crater landscape..",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Crater heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Crater depth.",
        "key": "depth",
        "type": "Float"
      },
      {
        "description": "Ejecta lip decay.",
        "key": "lip_decay",
        "type": "Float"
      },
      {
        "description": "Controls the ejecta lip relative height.",
        "key": "lip_height_ratio",
        "type": "Float"
      },
      {
        "description": "Crater radius.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "Crater.png"
  },
  "DataAnalysis": {
    "category": "Debug",
    "description": "DataAnalysis.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [],
    "parameters": [],
    "snapshot": "DataAnalysis.png"
  },
  "DataPreview": {
    "category": "Debug",
    "description": "DataPreview.",
    "inputs": [
      {
        "caption": "elevation",
        "description": "Data values for elevation preview.",
        "type": "HeightMap"
      },
      {
        "caption": "texture",
        "description": "Data values for color preview.",
        "type": "HeightMapRGBA"
      }
    ],
    "outputs": [],
    "parameters": [],
    "snapshot": "DataPreview.png"
  },
  "Dendry": {
    "category": "Primitive/Coherent Noise",
    "description": "Dendry is a procedural model for dendritic patterns generation.",
    "inputs": [
      {
        "caption": "control",
        "description": "Global control heightmap that defines the overall shape of the output.",
        "type": "HeightMap"
      },
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Maximum displacement of segments.",
        "key": "displacement",
        "type": "Float"
      },
      {
        "description": "Used to bias the area where points are generated in cells.",
        "key": "eps",
        "type": "Float"
      },
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Wavenumber"
      },
      {
        "description": "Proportion of the amplitude of the control function as noise.",
        "key": "noise_amplitude_proportion",
        "type": "Float"
      },
      {
        "description": "Additional resolution steps in the primitive resolution.",
        "key": "primitives_resolution_steps",
        "type": "Integer"
      },
      {
        "description": "Number of resolutions in the noise function.",
        "key": "resolution",
        "type": "Integer"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Additional parameter to control the variation of slope on terrains.",
        "key": "slope_power",
        "type": "Float"
      },
      {
        "description": "Function evaluation subsampling, use higher values for faster computation at the cost of a coarser resolution.",
        "key": "subsampling",
        "type": "Integer"
      }
    ],
    "snapshot": "Dendry.png"
  },
  "DepressionFilling": {
    "category": "Erosion",
    "description": "DepressionFilling is used to fill depressions or sinks in an heightmap. It ensures that there are no depressions, i.e. areas within a digital elevation model that are surrounded by higher terrain, with no outlet to lower areas.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filled heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "fill map",
        "description": "Filling map.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Minimum slope tolerance.",
        "key": "epsilon",
        "type": "Float"
      },
      {
        "description": "Maximum number of iterations.",
        "key": "iterations",
        "type": "Integer"
      },
      {
        "description": "Remap to [0, 1] the filling map.",
        "key": "remap fill map",
        "type": "Bool"
      }
    ],
    "snapshot": "DepressionFilling.png"
  },
  "Detrend": {
    "category": "Filter/Recurve",
    "description": "The Detrend operator is used to adjust the elevation using a very basic (uncorrect) detrending operator.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Detrended heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "Detrend.png"
  },
  "DiffusionLimitedAggregation": {
    "category": "Primitive/Coherent Noise",
    "description": "DiffusionLimitedAggregation creates branching, fractal-like structures that resemble the rugged, irregular contours of mountain ranges.",
    "inputs": [],
    "outputs": [
      {
        "caption": "output",
        "description": "DiffusionLimitedAggregation heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": " A parameter that controls the amount of randomness or noise introduced in the talus formation process.",
        "key": "noise_ratio",
        "type": "Float"
      },
      {
        "description": "A scaling factor that influences the density of the particles in the DLA pattern.",
        "key": "scale",
        "type": "Float"
      },
      {
        "description": "The seed for the random number generator.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "The ratio between the outer seeding radius and the initial seeding radius. It determines the outer boundary for particle seeding.",
        "key": "seeding_outer_radius_ratio",
        "type": "Float"
      },
      {
        "description": "The radius within which initial seeding of particles occurs. This radius defines the area where the first particles are placed.",
        "key": "seeding_radius",
        "type": "Float"
      },
      {
        "description": "Slope of the talus added to the DLA pattern.",
        "key": "slope",
        "type": "Float"
      }
    ],
    "snapshot": "DiffusionLimitedAggregation.png"
  },
  "Dilation": {
    "category": "Operator/Morphology",
    "description": "Dilation expands the boundaries of objects in an image and fills in small gaps or holes in those objects. Use Cases: (+) Filling gaps: Dilation can be used to fill small gaps or holes in objects, making them more solid. (+) Merging objects: Dilation can help merge nearby objects or connect broken segments in an image.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Dilated heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "Dilation.png"
  },
  "DistanceTransform": {
    "category": "Operator/Morphology",
    "description": "DistanceTransform is a distance map or distance image where each pixel's value represents the shortest distance to the nearest non-zero value in the input heightmap.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "DistanceTransform.png"
  },
  "Erosion": {
    "category": "Operator/Morphology",
    "description": "Erosion removes small structures or noise from an image, and it also shrinks the boundaries of objects in an image. Use Cases: (+) Noise reduction: Erosion can help remove small, unwanted pixels or noise from the image. (+) Separating objects: Erosion can be used to separate touching or overlapping objects in an image by shrinking their boundaries.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Dilated heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "Erosion.png"
  },
  "ExpandShrink": {
    "category": "Filter/Recast",
    "description": "ExpandShrink is a maximum/minimum filter with a weighted kernel. It can be used to enhance or extract features while preserving the essential structure of the heightmap.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Weighting kernel. Available values: biweight, cone, cone_smooth, cubic_pulse, disk, lorentzian, smooth_cosine, square, tricube.",
        "key": "kernel",
        "type": "Enumeration"
      },
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Shrink (if true) or expand (if false).",
        "key": "shrink",
        "type": "Bool"
      }
    ],
    "snapshot": "ExpandShrink.png"
  },
  "ExportAsset": {
    "category": "IO/Files",
    "description": "ExportAsset exporting both the heightmap and texture to a single asset.",
    "inputs": [
      {
        "caption": "elevation",
        "description": "Data values for elevation.",
        "type": "HeightMap"
      },
      {
        "caption": "texture",
        "description": "Data values for color.",
        "type": "HeightMapRGBA"
      }
    ],
    "outputs": [],
    "parameters": [
      {
        "description": "Decides whether the export is automatically performed when the node is updated.",
        "key": "auto_export",
        "type": "Bool"
      },
      {
        "description": "Elevation scaling.",
        "key": "elevation_scaling",
        "type": "Float"
      },
      {
        "description": "Export format. Available values: Assimp Binary - *.assbin, Assxml Document - *.assxml, Autodesk 3DS (legacy) - *.3ds, Autodesk FBX (ascii) - *.fbx, Autodesk FBX (binary) - *.fbx, COLLADA - Digital Asset Exchange Schema - *.dae, Extensible 3D - *.x3d, GL Transmission Format (binary) - *.glb, GL Transmission Format - *.gltf, GL Transmission Format v. 2 (binary) - *.glb, GL Transmission Format v. 2 - *.gltf, Stanford Polygon Library (binary) - *.ply, Stanford Polygon Library - *.ply, Step Files - *.stp, Stereolithography (binary) - *.stl, Stereolithography - *.stl, The 3MF-File-Format - *.3mf, Wavefront OBJ format - *.obj, Wavefront OBJ format without material file - *.obj.",
        "key": "export_format",
        "type": "Enumeration"
      },
      {
        "description": "Export file name.",
        "key": "fname",
        "type": "Filename"
      },
      {
        "description": "Maximum error (for optimized triangulated mesh).",
        "key": "max_error",
        "type": "Float"
      },
      {
        "description": "Mesh type for the geometry. Available values: triangles, triangles (optimized).",
        "key": "mesh_type",
        "type": "Enumeration"
      }
    ],
    "snapshot": "ExportAsset.png"
  },
  "ExportCloud": {
    "category": "IO/Files",
    "description": "ExportCloud is an operator for exporting cloud data to a csv file.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "Cloud"
      }
    ],
    "outputs": [],
    "parameters": [
      {
        "description": "Decides whether the export is automatically performed when the node is updated.",
        "key": "auto_export",
        "type": "Bool"
      },
      {
        "description": "Export file name.",
        "key": "fname",
        "type": "Filename"
      }
    ],
    "snapshot": "ExportCloud.png"
  },
  "ExportHeightmap": {
    "category": "IO/Files",
    "description": "ExportHeightmap is an operator for exporting a heightmap in various file formats.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [],
    "parameters": [
      {
        "description": "Decides whether the export is automatically performed when the node is updated.",
        "key": "auto_export",
        "type": "Bool"
      },
      {
        "description": "Export file name.",
        "key": "fname",
        "type": "Filename"
      },
      {
        "description": "Export format. Available values: png (16 bit), png (8 bit), raw (16 bit, Unity).",
        "key": "format",
        "type": "Enumeration"
      }
    ],
    "snapshot": "ExportHeightmap.png"
  },
  "ExportNormalMap": {
    "category": "IO/Files",
    "description": "ExportNormalMap is an operator for exporting the normal map of an heightmap as a PNG image file.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [],
    "parameters": [
      {
        "description": "Whether the output file is a 16bit PNG file (instead of 8bit).",
        "key": "16bit",
        "type": "Bool"
      },
      {
        "description": "Decides whether the export is automatically performed when the node is updated.",
        "key": "auto_export",
        "type": "Bool"
      },
      {
        "description": "Export file name.",
        "key": "fname",
        "type": "Filename"
      }
    ],
    "snapshot": "ExportNormalMap.png"
  },
  "ExportPath": {
    "category": "IO/Files",
    "description": "ExportPath is an operator for exporting path data to a csv file.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "Path"
      }
    ],
    "outputs": [],
    "parameters": [
      {
        "description": "Decides whether the export is automatically performed when the node is updated.",
        "key": "auto_export",
        "type": "Bool"
      },
      {
        "description": "Export file name.",
        "key": "fname",
        "type": "Filename"
      }
    ],
    "snapshot": "ExportPath.png"
  },
  "ExportTexture": {
    "category": "IO/Files",
    "description": "ExportTexture is a texture to a PNG image file.",
    "inputs": [
      {
        "caption": "texture",
        "description": "Input texture.",
        "type": "HeightMapRGBA"
      }
    ],
    "outputs": [],
    "parameters": [
      {
        "description": "Decides whether the output is an 8 bit or a 16 bit PNG file.",
        "key": "16 bit",
        "type": "Bool"
      },
      {
        "description": "Decides whether the export is automatically performed when the node is updated.",
        "key": "auto_export",
        "type": "Bool"
      },
      {
        "description": "Export file name.",
        "key": "fname",
        "type": "Filename"
      }
    ],
    "snapshot": "ExportTexture.png"
  },
  "Falloff": {
    "category": "Math/Boundaries",
    "description": "Falloff is an operator that enforces values close to zero at the domain edges.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "dr",
        "description": "Displacement with respect to the domain size (radial direction).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Measure used for the distance calculation. Available values: Chebyshev, Euclidian, Euclidian/Chebyshev, Manhattan.",
        "key": "distance_function",
        "type": "Enumeration"
      },
      {
        "description": "Falloff strength.",
        "key": "strength",
        "type": "Float"
      }
    ],
    "snapshot": "Falloff.png"
  },
  "FillTalus": {
    "category": "Operator/Transform",
    "description": "Fill the heightmap starting from the highest elevations using a regular downslope.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Noise ratio, added to the downslope.",
        "key": "noise_ratio",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Downslope used for filling.",
        "key": "slope",
        "type": "Float"
      }
    ],
    "snapshot": "FillTalus.png"
  },
  "Fold": {
    "category": "Filter/Recast",
    "description": "Fold iteratively applies the absolute value function to the input field, effectively folding negative values to their positive counterparts.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Folded heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Number of successive foldings.",
        "key": "iterations",
        "type": "Integer"
      },
      {
        "description": "Smoothing parameter of the smooth absolute value.",
        "key": "k",
        "type": "Float"
      }
    ],
    "snapshot": "Fold.png"
  },
  "Gain": {
    "category": "Filter/Recurve",
    "description": "Gain is a power law transformation altering the distribution of signal values, compressing or expanding certain regions of the signal depending on the exponent of the power law.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Power law exponent.",
        "key": "gain",
        "type": "Float"
      }
    ],
    "snapshot": "Gain.png"
  },
  "GammaCorrection": {
    "category": "Filter/Recurve",
    "description": "Gamma correction involves applying a nonlinear transformation to the pixel values of the heightmap. This transformation is based on a power-law function, where each pixel value is raised to the power of the gamma value. The gamma value is a parameter that determines the degree and direction of the correction.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Gamma exponent.",
        "key": "gamma",
        "type": "Float"
      }
    ],
    "snapshot": "GammaCorrection.png"
  },
  "GammaCorrectionLocal": {
    "category": "Filter/Recurve",
    "description": "Gamma correction involves applying a nonlinear transformation to the pixel values of the heightmap. For GammaCorrectionLocal, the transformation parameters are locally defined within a perimeter 'radius'.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Gamma exponent.",
        "key": "gamma",
        "type": "Float"
      },
      {
        "description": "Smoothing factor (typically in [0, 1]).",
        "key": "k",
        "type": "Float"
      },
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "GammaCorrectionLocal.png"
  },
  "GaussianDecay": {
    "category": "Math/Base",
    "description": "Apply a Gaussian function to every values.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Gaussian half-width, represents the distance from the peak of the Gaussian curve to the points where the amplitude drops to half of its maximum value.",
        "key": "sigma",
        "type": "Float"
      }
    ],
    "snapshot": "GaussianDecay.png"
  },
  "GaussianPulse": {
    "category": "Primitive/Function",
    "description": "GaussianPulse generates a Gaussian pulse.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Gaussian heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Center x coordinate.",
        "key": "center.x",
        "type": "Float"
      },
      {
        "description": "Center y coordinate.",
        "key": "center.y",
        "type": "Float"
      },
      {
        "description": "Pulse half-width.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "GaussianPulse.png"
  },
  "Gradient": {
    "category": "Math/Gradient",
    "description": "Gradient provides insight into the spatial distribution of a function's gradient, conveying both direction and intensity of change across the xy-plane",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "dx",
        "description": "Gradient with respect to the x-direction.",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Gradient with respect to the y-direction.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "Gradient.png"
  },
  "GradientAngle": {
    "category": "Math/Gradient",
    "description": "The gradient angle of a heightmap refers to the direction in which the elevation changes most rapidly at each point on the map. It represents the slope or inclination of the terrain surface relative to a horizontal plane",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Gradient angle.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "GradientAngle.png"
  },
  "GradientNorm": {
    "category": "Math/Gradient",
    "description": "The gradient norm of a heightmap refers to the magnitude or intensity of the rate of change of elevation at each point on the map. It represents the steepness or slope of the terrain surface, irrespective of its direction.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Gradient norm.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "GradientNorm.png"
  },
  "GradientTalus": {
    "category": "Math/Gradient",
    "description": "Gradient talus refers to the local steepest downslope, or the direction in which the terrain descends most rapidly, at each point on the heightmap.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Gradient talus.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "GradientTalus.png"
  },
  "HeightmapToKernel": {
    "category": "Converter",
    "description": "Convert an heightmap to a kernel.",
    "inputs": [
      {
        "caption": "input",
        "description": "Heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "kernel",
        "description": "Kernel.",
        "type": "Kernel"
      }
    ],
    "parameters": [
      {
        "description": "Determine if an enveloppe is applied to the kernel.",
        "key": "envelope",
        "type": "Bool"
      },
      {
        "description": "Envelope kernel. Available values: biweight, cone, cone_smooth, cubic_pulse, disk, lorentzian, smooth_cosine, square, tricube.",
        "key": "envelope_kernel",
        "type": "Enumeration"
      },
      {
        "description": "Normalize kernel so that the sum of the elements equals 1, preserving the overall intensity of an heightmap after convolution for instance.",
        "key": "normalize",
        "type": "Bool"
      },
      {
        "description": "Kernel radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "HeightmapToKernel.png"
  },
  "HeightmapToMask": {
    "category": "Converter",
    "description": "Convert an heightmap to a mask (remap values).",
    "inputs": [
      {
        "caption": "input",
        "description": "Heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "mask",
        "description": "Mask.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "HeightmapToMask.png"
  },
  "HeightmapToRGBA": {
    "category": "Converter",
    "description": "HeightmapToRGBA converts a series of heightmaps into an RGBA splatmap.",
    "inputs": [
      {
        "caption": "R",
        "description": "Red channel.",
        "type": "HeightMap"
      },
      {
        "caption": "G",
        "description": "Green channel.",
        "type": "HeightMap"
      },
      {
        "caption": "B",
        "description": "Blue channel.",
        "type": "HeightMap"
      },
      {
        "caption": "A",
        "description": "Alpha channel.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "RGBA",
        "description": "RGBA heightmap.",
        "type": "HeightMapRGBA"
      }
    ],
    "parameters": [],
    "snapshot": "HeightmapToRGBA.png"
  },
  "HydraulicBlur": {
    "category": "Erosion/Hydraulic",
    "description": "Hydraulic Blur applied a cell-based hydraulic erosion using a nonlinear diffusion model.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Eroded heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Smoothing factor, if any.",
        "key": "k_smoothing",
        "type": "Float"
      },
      {
        "description": "Gaussian filter radius (with respect to a unit domain).",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Maximum elevation for the details.",
        "key": "vmax",
        "type": "Float"
      }
    ],
    "snapshot": "HydraulicBlur.png"
  },
  "HydraulicParticle": {
    "category": "Erosion/Hydraulic",
    "description": "HydraulicParticle is a particle-based hydraulic erosion operator that simulates the erosion and sediment transport processes that occur due to the flow of water over a terrain represented by the input heightmap. This type of operator models erosion by tracking the movement of virtual particles (or sediment particles) as they are transported by water flow and interact with the terrain.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "bedrock",
        "description": "Bedrock elevation, erosion process cannot carve the heightmap further down this point.",
        "type": "HeightMap"
      },
      {
        "caption": "moisture",
        "description": "Moisture map, influences the amount of water locally deposited.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Eroded heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "erosion map",
        "description": "Erosion map",
        "type": "HeightMap"
      },
      {
        "caption": "depo. map",
        "description": "Deposition map",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Particle capacity.",
        "key": "c_capacity",
        "type": "Float"
      },
      {
        "description": "Particle deposition coefficient.",
        "key": "c_deposition",
        "type": "Float"
      },
      {
        "description": "Particle erosion cofficient.",
        "key": "c_erosion",
        "type": "Float"
      },
      {
        "description": "Particle radius (c_radius = 0 for a pixel-based algorithm and c_radius > 0 for a kernel-based algorithm, which can be significantly slower).",
        "key": "c_radius",
        "type": "Integer"
      },
      {
        "description": "Particle drag rate.",
        "key": "drag_rate",
        "type": "Float"
      },
      {
        "description": "Particle water evaporation rate.",
        "key": "evap_rate",
        "type": "Float"
      },
      {
        "description": "Number of simulated particles.",
        "key": "nparticles",
        "type": "Integer"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "HydraulicParticle.png"
  },
  "HydraulicRidge": {
    "category": "Erosion/Hydraulic",
    "description": "HydraulicRidge .",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Erosion factor, generally in ]0, 10]. Smaller values tend to flatten the map.",
        "key": "erosion_factor",
        "type": "Float"
      },
      {
        "description": "Intensity mask, expected in [0, 1] (applied as a post-processing).",
        "key": "intensity",
        "type": "Float"
      },
      {
        "description": "Ridge talus noise ratio in [0, 1].",
        "key": "noise_ratio",
        "type": "Float"
      },
      {
        "description": "Pre-filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Smooothing factor in ]0, 1] (1 for no smoothing).",
        "key": "smoothing_factor",
        "type": "Float"
      },
      {
        "description": "Ridge slope.",
        "key": "talus_global",
        "type": "Float"
      }
    ],
    "snapshot": "HydraulicRidge.png"
  },
  "HydraulicStream": {
    "category": "Erosion/Hydraulic",
    "description": "HydraulicStream is an hydraulic erosion operator using the flow stream approach and an infinite flow direction algorithm for simulating the erosion processes. Simulate water flow across the terrain using the infinite flow direction algorithm. As water flows over the terrain, flow accumulation representing the volume of water that passes through each point on the map, is computed to evaluate the erosive power of the water flow.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "bedrock",
        "description": "Bedrock elevation, erosion process cannot carve the heightmap further down this point.",
        "type": "HeightMap"
      },
      {
        "caption": "moisture",
        "description": "Moisture map, influences the amount of water locally deposited.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Eroded heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "erosion map",
        "description": "Erosion map",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Erosion intensity.",
        "key": "c_erosion",
        "type": "Float"
      },
      {
        "description": "Flow accumulation clipping ratio.",
        "key": "clipping_ratio",
        "type": "Float"
      },
      {
        "description": "Carving kernel radius.",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Reference talus, with small values of talus_ref  leading to thinner flow streams.",
        "key": "talus_ref",
        "type": "Float"
      }
    ],
    "snapshot": "HydraulicStream.png"
  },
  "HydraulicVpipes": {
    "category": "Erosion/Hydraulic",
    "description": "HydraulicVpipes performs hydraulic erosion using a virtual pipe algorithm, which is a method that simulates erosion and sediment transport processes by mimicking the behavior of water flowing through a network of virtual pipes. This approach models erosion based on the principles of fluid dynamics and sediment transport, while also considering the local topography of the terrain represented by the input heightmap.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "bedrock",
        "description": "Bedrock elevation, erosion process cannot carve the heightmap further down this point.",
        "type": "HeightMap"
      },
      {
        "caption": "moisture",
        "description": "Moisture map, influences the amount of water locally deposited.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Eroded heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "erosion map",
        "description": "Erosion map",
        "type": "HeightMap"
      },
      {
        "caption": "depo. map",
        "description": "Deposition map",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Particle capacity.",
        "key": "c_capacity",
        "type": "Float"
      },
      {
        "description": "Particle deposition coefficient.",
        "key": "c_deposition",
        "type": "Float"
      },
      {
        "description": "Particle erosion cofficient.",
        "key": "c_erosion",
        "type": "Float"
      },
      {
        "description": "Particle water evaporation rate.",
        "key": "evap_rate",
        "type": "Float"
      },
      {
        "description": "Number of simulation iterations.",
        "key": "iterations",
        "type": "Integer"
      },
      {
        "description": "Water evaporation rate.",
        "key": "rain_rate",
        "type": "Float"
      },
      {
        "description": "Total water height..",
        "key": "water_height",
        "type": "Float"
      }
    ],
    "snapshot": "HydraulicVpipes.png"
  },
  "ImportHeightmap": {
    "category": "IO/Files",
    "description": "ImportHeightmap imports an heighmap from a grayscale PNG 8bit file.",
    "inputs": [],
    "outputs": [
      {
        "caption": "texture",
        "description": "Heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Import file name.",
        "key": "fname (8bit grayscale)",
        "type": "Filename"
      },
      {
        "description": "Remap imported heightmap elevation to [0, 1].",
        "key": "remap",
        "type": "Bool"
      }
    ],
    "snapshot": "ImportHeightmap.png"
  },
  "Inverse": {
    "category": "Math/Base",
    "description": "Inverse flips the sign of every values.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Binary heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "Inverse.png"
  },
  "KernelGabor": {
    "category": "Primitive/Kernel",
    "description": ".",
    "inputs": [],
    "outputs": [
      {
        "caption": "kernel",
        "description": "KernelGabor generates a Gabor kernel.",
        "type": "Kernel"
      }
    ],
    "parameters": [
      {
        "description": "Kernel angle.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Kernel wavenumber (spatial frequency).",
        "key": "kw",
        "type": "Float"
      },
      {
        "description": "Normalize kernel so that the sum of the elements equals 1, preserving the overall intensity of an heightmap after convolution for instance.",
        "key": "normalize",
        "type": "Bool"
      },
      {
        "description": "Kernel radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "KernelGabor.png"
  },
  "KernelPrim": {
    "category": "Primitive/Kernel",
    "description": ".",
    "inputs": [],
    "outputs": [
      {
        "caption": "kernel",
        "description": "KernelPrim generates a 'kernel', refering to a small matrix used to apply specific effects based on convolution for instance.",
        "type": "Kernel"
      }
    ],
    "parameters": [
      {
        "description": "Kernel type. Available values: biweight, cone, cone_smooth, cubic_pulse, disk, lorentzian, smooth_cosine, square, tricube.",
        "key": "kernel",
        "type": "Enumeration"
      },
      {
        "description": "Normalize kernel so that the sum of the elements equals 1, preserving the overall intensity of an heightmap after convolution for instance.",
        "key": "normalize",
        "type": "Bool"
      },
      {
        "description": "Kernel radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "KernelPrim.png"
  },
  "KmeansClustering2": {
    "category": "Features/Clustering",
    "description": "KmeansClustering2 node groups the data into clusters based on the values of the two input features.",
    "inputs": [
      {
        "caption": "feature 1",
        "description": "First measurable property or characteristic of the data points being analyzed (e.g elevation, gradient norm, etc...",
        "type": "HeightMap"
      },
      {
        "caption": "feature 2",
        "description": "Second measurable property or characteristic of the data points being analyzed (e.g elevation, gradient norm, etc...",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Cluster labelling.",
        "type": "HeightMap"
      },
      {
        "caption": "scoring",
        "description": "Score in [0, 1] of the cell to belong to a given cluster",
        "type": "HeightMapVector"
      }
    ],
    "parameters": [
      {
        "description": "Determine whether scoring is computed.",
        "key": "compute_scoring",
        "type": "Bool"
      },
      {
        "description": "Number of clusters.",
        "key": "nclusters",
        "type": "Integer"
      },
      {
        "description": "Determine whether the feature amplitudes are normalized before the clustering.",
        "key": "normalize_inputs",
        "type": "Bool"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Weight of the first feature.",
        "key": "weights.x",
        "type": "Float"
      },
      {
        "description": "Weight of the second feature.",
        "key": "weights.y",
        "type": "Float"
      }
    ],
    "snapshot": "KmeansClustering2.png"
  },
  "KmeansClustering3": {
    "category": "Features/Clustering",
    "description": "KmeansClustering2 node groups the data into clusters based on the values of the three input features.",
    "inputs": [
      {
        "caption": "feature 1",
        "description": "First measurable property or characteristic of the data points being analyzed (e.g elevation, gradient norm, etc...",
        "type": "HeightMap"
      },
      {
        "caption": "feature 2",
        "description": "First measurable property or characteristic of the data points being analyzed (e.g elevation, gradient norm, etc...",
        "type": "HeightMap"
      },
      {
        "caption": "feature 3",
        "description": "Third measurable property or characteristic of the data points being analyzed (e.g elevation, gradient norm, etc...",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Cluster labelling.",
        "type": "HeightMap"
      },
      {
        "caption": "scoring",
        "description": "Score in [0, 1] of the cell to belong to a given cluster",
        "type": "HeightMapVector"
      }
    ],
    "parameters": [
      {
        "description": "Determine whether scoring is computed.",
        "key": "compute_scoring",
        "type": "Bool"
      },
      {
        "description": "Number of clusters.",
        "key": "nclusters",
        "type": "Integer"
      },
      {
        "description": "Determine whether the feature amplitudes are normalized before the clustering.",
        "key": "normalize_inputs",
        "type": "Bool"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Weight of the first feature.",
        "key": "weights.x",
        "type": "Float"
      },
      {
        "description": "Weight of the third feature.",
        "key": "weights.y",
        "type": "Float"
      }
    ],
    "snapshot": "KmeansClustering3.png"
  },
  "Laplace": {
    "category": "Filter/Smoothing",
    "description": "Laplace smoothing filter reduces noise and smooth out variations in pixel intensity while preserving the overall structure of an image.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Number of successive filtering iterations.",
        "key": "iterations",
        "type": "Integer"
      },
      {
        "description": "Filtering strength.",
        "key": "sigma",
        "type": "Float"
      }
    ],
    "snapshot": "Laplace.png"
  },
  "Lerp": {
    "category": "Operator/Blend",
    "description": "The Lerp operator, short for linear interpolation, is a method for smoothly transitioning between two values over a specified range or interval.",
    "inputs": [
      {
        "caption": "a",
        "description": "Start heightmap (t = 0).",
        "type": "HeightMap"
      },
      {
        "caption": "b",
        "description": "End heightmap (t = 1).",
        "type": "HeightMap"
      },
      {
        "caption": "t",
        "description": "Lerp factor, expected in [0, 1].",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Interpolated heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Lerp factor (in [0, 1]). Used only if the node input 't' is not set.",
        "key": "t",
        "type": "Float"
      }
    ],
    "snapshot": "Lerp.png"
  },
  "MakeBinary": {
    "category": "Operator/Morphology",
    "description": "MakeBinary is a thresholding operator. It transforms an input heightmap into a binary heightmap, where each pixel is assigned either a value of 0 or 1, depending on whether its intensity value surpasses a specified threshold.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Binary heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Threshold value.",
        "key": "threshold",
        "type": "Float"
      }
    ],
    "snapshot": "MakeBinary.png"
  },
  "MakePeriodic": {
    "category": "Operator/Tiling",
    "description": "MakePeriodic makes the input heightmap tileable by building a smooth lineat transition at the boundaries.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Binary heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Overlap ratio at the boundaries.",
        "key": "overlap",
        "type": "Float"
      }
    ],
    "snapshot": "MakePeriodic.png"
  },
  "MakePeriodicStitching": {
    "category": "Operator/Tiling",
    "description": "MakePeriodicStitching makes the input heightmap tileable by seamlessly stitching together the domain boundaries.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Binary heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Overlap ratio at the boundaries.",
        "key": "overlap",
        "type": "Float"
      }
    ],
    "snapshot": "MakePeriodicStitching.png"
  },
  "Median3x3": {
    "category": "Filter/Smoothing",
    "description": "Median3x3 filter is a median filter with a 3x3 kernel used to reduce noise while preserving edges in an image. This process removes outliers and smooths the image without noise reduction and feature preservation in digital images.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "Median3x3.png"
  },
  "MixTexture": {
    "category": "Texture",
    "description": "MixTexture enables the seamless integration of multiple textures by utilizing the alpha channel information to control the blending.",
    "inputs": [
      {
        "caption": "texture1",
        "description": "Input texture.",
        "type": "HeightMapRGBA"
      },
      {
        "caption": "texture2",
        "description": "Input texture.",
        "type": "HeightMapRGBA"
      },
      {
        "caption": "texture3",
        "description": "Input texture.",
        "type": "HeightMapRGBA"
      },
      {
        "caption": "texture4",
        "description": "Input texture.",
        "type": "HeightMapRGBA"
      }
    ],
    "outputs": [
      {
        "caption": "texture",
        "description": "Output texture.",
        "type": "HeightMapRGBA"
      }
    ],
    "parameters": [
      {
        "description": "Reset the output alpha channel to 1 (opaque).",
        "key": "reset_output_alpha",
        "type": "Bool"
      },
      {
        "description": "Use square averaging for alpha-compositing (instead of linear averaging).",
        "key": "use_sqrt_avg",
        "type": "Bool"
      }
    ],
    "snapshot": "MixTexture.png"
  },
  "Mixer": {
    "category": "Operator/Blend",
    "description": "The Mixer operator takes several input heightmaps and blend them according to a mixing parameter expected in [0, 1].",
    "inputs": [
      {
        "caption": "input 1",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "input 2",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "input 3",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "input 4",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "t",
        "description": "Mixing parameter, expected in [0, 1].",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "Mixer.png"
  },
  "MorphologicalGradient": {
    "category": "Operator/Morphology",
    "description": "MorphologicalGradient calculates the difference between dilation and erosion of an image, resulting in the outline of objects. Use Cases: Edge detection, boundary extraction.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Gradient heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "MorphologicalGradient.png"
  },
  "Noise": {
    "category": "Primitive/Coherent Noise",
    "description": "Noise node generates coherent and random-looking patterns.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Wavenumber"
      },
      {
        "description": "Base primitive noise. Available values: OpenSimplex2, OpenSimplex2S, Perlin, Perlin (billow), Perlin (half), Value, Value (cubic), Value (delaunay), Value (linear), Worley, Worley (doube), Worley (value).",
        "key": "noise_type",
        "type": "Enumeration"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "Noise.png"
  },
  "NoiseFbm": {
    "category": "Primitive/Coherent Noise",
    "description": "Fractal noise is a mathematical algorithm used to generate complex and detailed patterns characterized by self-similarity across different scales.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      },
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Wavenumber"
      },
      {
        "description": "Wavenumber ratio between each octaves.",
        "key": "lacunarity",
        "type": "Float"
      },
      {
        "description": "Base primitive noise. Available values: OpenSimplex2, OpenSimplex2S, Perlin, Perlin (billow), Perlin (half), Value, Value (cubic), Worley, Worley (doube), Worley (value).",
        "key": "noise_type",
        "type": "Enumeration"
      },
      {
        "description": "Number of octaves.",
        "key": "octaves",
        "type": "Integer"
      },
      {
        "description": "Octave persistence.",
        "key": "persistence",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Octave weighting.",
        "key": "weight",
        "type": "Float"
      }
    ],
    "snapshot": "NoiseFbm.png"
  },
  "NoiseIq": {
    "category": "Primitive/Coherent Noise",
    "description": "NoiseIq, variant of NoiseFbm.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      },
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Gradient influence scaling.",
        "key": "gradient_scale",
        "type": "Float"
      },
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Wavenumber"
      },
      {
        "description": "Wavenumber ratio between each octaves.",
        "key": "lacunarity",
        "type": "Float"
      },
      {
        "description": "Base primitive noise. Available values: OpenSimplex2, OpenSimplex2S, Perlin, Perlin (billow), Perlin (half), Value, Value (cubic), Worley, Worley (doube), Worley (value).",
        "key": "noise_type",
        "type": "Enumeration"
      },
      {
        "description": "Number of octaves.",
        "key": "octaves",
        "type": "Integer"
      },
      {
        "description": "Octave persistence.",
        "key": "persistence",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Octave weighting.",
        "key": "weight",
        "type": "Float"
      }
    ],
    "snapshot": "NoiseIq.png"
  },
  "NoiseJordan": {
    "category": "Primitive/Coherent Noise",
    "description": "NoiseJordan, variant of NoiseFbm.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      },
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Damping initial value.",
        "key": "damp0",
        "type": "Float"
      },
      {
        "description": "Damping influence scaling.",
        "key": "damp_scale",
        "type": "Float"
      },
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Wavenumber"
      },
      {
        "description": "Wavenumber ratio between each octaves.",
        "key": "lacunarity",
        "type": "Float"
      },
      {
        "description": "Base primitive noise. Available values: OpenSimplex2, OpenSimplex2S, Perlin, Perlin (billow), Perlin (half), Value, Value (cubic), Worley, Worley (doube), Worley (value).",
        "key": "noise_type",
        "type": "Enumeration"
      },
      {
        "description": "Number of octaves.",
        "key": "octaves",
        "type": "Integer"
      },
      {
        "description": "Octave persistence.",
        "key": "persistence",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Warping initial value.",
        "key": "warp0",
        "type": "Float"
      },
      {
        "description": "Warping influence scaling.",
        "key": "warp_scale",
        "type": "Float"
      },
      {
        "description": "Octave weighting.",
        "key": "weight",
        "type": "Float"
      }
    ],
    "snapshot": "NoiseJordan.png"
  },
  "NoiseParberry": {
    "category": "Primitive/Coherent Noise",
    "description": "NoiseParberry, variant of NoiseFbm, is a Perlin noise based terrain generator from Ian Parberry, Tobler's First Law of Geography, Self Similarity, and Perlin Noise: A Large Scale Analysis of Gradient Distribution in Southern Utah with Application to Procedural Terrain Generation.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      },
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Wavenumber"
      },
      {
        "description": "Wavenumber ratio between each octaves.",
        "key": "lacunarity",
        "type": "Float"
      },
      {
        "description": "Gradient magnitude exponent.",
        "key": "mu",
        "type": "Float"
      },
      {
        "description": "Number of octaves.",
        "key": "octaves",
        "type": "Integer"
      },
      {
        "description": "Octave persistence.",
        "key": "persistence",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Octave weighting.",
        "key": "weight",
        "type": "Float"
      }
    ],
    "snapshot": "NoiseParberry.png"
  },
  "NoisePingpong": {
    "category": "Primitive/Coherent Noise",
    "description": "NoisePingPong, variant of NoiseFbm.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      },
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Wavenumber"
      },
      {
        "description": "Wavenumber ratio between each octaves.",
        "key": "lacunarity",
        "type": "Float"
      },
      {
        "description": "Base primitive noise. Available values: OpenSimplex2, OpenSimplex2S, Perlin, Perlin (billow), Perlin (half), Value, Value (cubic), Worley, Worley (doube), Worley (value).",
        "key": "noise_type",
        "type": "Enumeration"
      },
      {
        "description": "Number of octaves.",
        "key": "octaves",
        "type": "Integer"
      },
      {
        "description": "Octave persistence.",
        "key": "persistence",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Octave weighting.",
        "key": "weight",
        "type": "Float"
      }
    ],
    "snapshot": "NoisePingpong.png"
  },
  "NoiseRidged": {
    "category": "Primitive/Coherent Noise",
    "description": "NoiseRidged, variant of NoiseFbm.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      },
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Smoothing coefficient of the aboslute value.",
        "key": "k_smoothing",
        "type": "Float"
      },
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Wavenumber"
      },
      {
        "description": "Wavenumber ratio between each octaves.",
        "key": "lacunarity",
        "type": "Float"
      },
      {
        "description": "Base primitive noise. Available values: OpenSimplex2, OpenSimplex2S, Perlin, Perlin (billow), Perlin (half), Value, Value (cubic), Worley, Worley (doube), Worley (value).",
        "key": "noise_type",
        "type": "Enumeration"
      },
      {
        "description": "Number of octaves.",
        "key": "octaves",
        "type": "Integer"
      },
      {
        "description": "Octave persistence.",
        "key": "persistence",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Octave weighting.",
        "key": "weight",
        "type": "Float"
      }
    ],
    "snapshot": "NoiseRidged.png"
  },
  "NoiseSwiss": {
    "category": "Primitive/Coherent Noise",
    "description": "NoiseSwiss, variant of NoiseFbm.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      },
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Wavenumber"
      },
      {
        "description": "Wavenumber ratio between each octaves.",
        "key": "lacunarity",
        "type": "Float"
      },
      {
        "description": "Base primitive noise. Available values: OpenSimplex2, OpenSimplex2S, Perlin, Perlin (billow), Perlin (half), Value, Value (cubic), Worley, Worley (doube), Worley (value).",
        "key": "noise_type",
        "type": "Enumeration"
      },
      {
        "description": "Number of octaves.",
        "key": "octaves",
        "type": "Integer"
      },
      {
        "description": "Octave persistence.",
        "key": "persistence",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Warping influence scaling.",
        "key": "warp_scale",
        "type": "Float"
      },
      {
        "description": "Octave weighting.",
        "key": "weight",
        "type": "Float"
      }
    ],
    "snapshot": "NoiseSwiss.png"
  },
  "NormalDisplacement": {
    "category": "Filter/Recast",
    "description": "NormalDisplacement applies a displacement to the terrain along the normal direction.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Displacement scaling.",
        "key": "amount",
        "type": "Float"
      },
      {
        "description": "Number of successive use of the operator.",
        "key": "iterations",
        "type": "Integer"
      },
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Reverse displacement direction.",
        "key": "reverse",
        "type": "Bool"
      }
    ],
    "snapshot": "NormalDisplacement.png"
  },
  "Opening": {
    "category": "Operator/Morphology",
    "description": "Opening is a combination of erosion followed by dilation. It is primarily used for removing noise while preserving the shape and size of objects. Use Cases: Noise removal: Opening is effective in removing small, isolated noise regions while keeping the main objects intact. Smoothing object boundaries: Opening can help smooth the boundaries of objects in an image while preserving their overall shape.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Dilated heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "Opening.png"
  },
  "Paraboloid": {
    "category": "Primitive/Function",
    "description": ".",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Paraboloid.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Curvature parameter, first principal axis.",
        "key": "a",
        "type": "Float"
      },
      {
        "description": "Angle.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Curvature parameter, second principal axis.",
        "key": "b",
        "type": "Float"
      },
      {
        "description": "Center x coordinate.",
        "key": "center.x",
        "type": "Float"
      },
      {
        "description": "Center y coordinate.",
        "key": "center.y",
        "type": "Float"
      },
      {
        "description": "Reverse coefficient of first principal axis.",
        "key": "reverse_x",
        "type": "Bool"
      },
      {
        "description": "Reverse coefficient of second principal axis.",
        "key": "reverse_y",
        "type": "Bool"
      },
      {
        "description": "Value at the paraboloid center.",
        "key": "v0",
        "type": "Float"
      }
    ],
    "snapshot": "Paraboloid.png"
  },
  "Path": {
    "category": "Geometry/Path",
    "description": "Polyline definition.",
    "inputs": [],
    "outputs": [
      {
        "caption": "path",
        "description": "Set of directed points (x, y) and elevations z.",
        "type": "Path"
      }
    ],
    "parameters": [
      {
        "description": "Decides whether the path is open and closed on itself.",
        "key": "closed",
        "type": "Bool"
      },
      {
        "description": "Path data.",
        "key": "path",
        "type": "HighMap Path object"
      },
      {
        "description": "Decides whether the path points are reordered using a nearest neighbor search.",
        "key": "reorder_nns",
        "type": "Bool"
      }
    ],
    "snapshot": "Path.png"
  },
  "PathBezier": {
    "category": "Geometry/Path",
    "description": "PathBezier uses Bezier interpolation to replace sharp angles and straight segments with smooth, flowing curves.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input path.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output path.",
        "type": "Path"
      }
    ],
    "parameters": [
      {
        "description": "Amount of curvature (usually in [-1, 1] and commonly > 0).",
        "key": "curvature_ratio",
        "type": "Float"
      },
      {
        "description": "Edge sub-divisions of each edge. After the operation, the path is remeshed based on this new sub-division.",
        "key": "edge_divisions",
        "type": "Integer"
      }
    ],
    "snapshot": "PathBezier.png"
  },
  "PathBezierRound": {
    "category": "Geometry/Path",
    "description": "PathBezierRound uses Bezier interpolation to replace sharp angles and straight segments with smooth, round and flowing curves. PathBezierRound is an alternative to PathBezier.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input path.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output path.",
        "type": "Path"
      }
    ],
    "parameters": [
      {
        "description": "Amount of curvature (usually in [-1, 1] and commonly > 0).",
        "key": "curvature_ratio",
        "type": "Float"
      },
      {
        "description": "Edge sub-divisions of each edge. After the operation, the path is remeshed based on this new sub-division.",
        "key": "edge_divisions",
        "type": "Integer"
      }
    ],
    "snapshot": "PathBezierRound.png"
  },
  "PathBspline": {
    "category": "Geometry/Path",
    "description": "PathBspline uses Bspline interpolation to replace sharp angles and straight segments with smooth, flowing curves.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input path.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output path.",
        "type": "Path"
      }
    ],
    "parameters": [
      {
        "description": "Edge sub-divisions of each edge. After the operation, the path is remeshed based on this new sub-division.",
        "key": "edge_divisions",
        "type": "Integer"
      }
    ],
    "snapshot": "PathBspline.png"
  },
  "PathDecasteljau": {
    "category": "Geometry/Path",
    "description": "PathDecasteljau uses Decasteljau interpolation to replace sharp angles and straight segments with smooth, flowing curves.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input path.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output path.",
        "type": "Path"
      }
    ],
    "parameters": [
      {
        "description": "Edge sub-divisions of each edge. After the operation, the path is remeshed based on this new sub-division.",
        "key": "edge_divisions",
        "type": "Integer"
      }
    ],
    "snapshot": "PathDecasteljau.png"
  },
  "PathFractalize": {
    "category": "Geometry/Path",
    "description": "PathFractalize fractalizes a polyline using a mid-point displacement algorithm. The procedure involves iteratively modifying the polyline's geometry to increase its complexity, mimicking fractal characteristics.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input path.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output path.",
        "type": "Path"
      }
    ],
    "parameters": [
      {
        "description": "Number of mid-point displacement iterations.",
        "key": "iterations",
        "type": "Integer"
      },
      {
        "description": "Displacement orientation (0 for random inward/outward displacement, 1 to inflate the path and -1 to deflate the path).",
        "key": "orientation",
        "type": "Integer"
      },
      {
        "description": "Noise persistence (with iteration number).",
        "key": "persistence",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Half-width of the random Gaussian displacement, normalized by the distance between points.",
        "key": "sigma",
        "type": "Float"
      }
    ],
    "snapshot": "PathFractalize.png"
  },
  "PathMeanderize": {
    "category": "Geometry/Path",
    "description": "PathMeanderize uses Bezier interpolation to add menaders to the input path.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input path.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output path.",
        "type": "Path"
      }
    ],
    "parameters": [
      {
        "description": "Edge sub-divisions of each edge. After the operation, the path is remeshed based on this new sub-division.",
        "key": "edge_divisions",
        "type": "Integer"
      },
      {
        "description": "Number of meandering iterations.",
        "key": "iterations",
        "type": "Integer"
      },
      {
        "description": "Randomness ratio.",
        "key": "noise_ratio",
        "type": "Float"
      },
      {
        "description": "Meander amplitude ratio.",
        "key": "ratio",
        "type": "Float"
      },
      {
        "description": "Random seed number",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "PathMeanderize.png"
  },
  "PathResample": {
    "category": "Geometry/Path",
    "description": "PathResample resamples the path based to get (approximately) a given distance between points.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input path.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output path.",
        "type": "Path"
      }
    ],
    "parameters": [
      {
        "description": "Target distance between the points.",
        "key": "delta",
        "type": "Float"
      }
    ],
    "snapshot": "PathResample.png"
  },
  "PathSDF": {
    "category": "Geometry/Path",
    "description": "PathSDF evaluates the signed distance function of a polyline. It assigns a signed distance value to every point in space. For points outside the polyline, the distance is positive, while for points inside, it's negative. The zero level set of this function precisely defines the polyline's path Project path points to an heightmap.",
    "inputs": [
      {
        "caption": "path",
        "description": "Input path.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "sdf",
        "description": "Signed distance as an heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "PathSDF.png"
  },
  "PathToCloud": {
    "category": "Converter",
    "description": "PathToCloud convert a Path to a set of points (Cloud).",
    "inputs": [
      {
        "caption": "path",
        "description": "Input path.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "cloud",
        "description": "Output cloud.",
        "type": "Cloud"
      }
    ],
    "parameters": [],
    "snapshot": "PathToCloud.png"
  },
  "PathToHeightmap": {
    "category": "Geometry/Path",
    "description": "PathToHeightmap Project path points to an heightmap.",
    "inputs": [
      {
        "caption": "path",
        "description": "Input path.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "heightmap",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Whether the resulting path contour is filled (input Path needs to be closed).",
        "key": "filled",
        "type": "Bool"
      }
    ],
    "snapshot": "PathToHeightmap.png"
  },
  "Plateau": {
    "category": "Filter/Recurve",
    "description": "Plateau node manipulates the elevation values to create flats, elevated regions surrounded by steep slopes.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Influence the cliff elevation profile.",
        "key": "factor",
        "type": "Float"
      },
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "Plateau.png"
  },
  "QuiltingExpand": {
    "category": "Operator/Expand",
    "description": "QuiltingExpand is an operator based on quilting that changes the feature wavenumber of a heightmap by modifying the frequency or scale of features present in the heightmap using a quilting-like technique. This operator allows for the synthesis of heightmaps with different levels of detail or spatial frequency content.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Synthetized heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Determine the features expansion ratio of the new heightmap.",
        "key": "expansion_ratio",
        "type": "Float"
      },
      {
        "description": "Smooth filter width with respect the overlap length.",
        "key": "filter_width_ratio",
        "type": "Float"
      },
      {
        "description": "Overlap ratio between patches.",
        "key": "overlap",
        "type": "Float"
      },
      {
        "description": "Allow patch flipping.",
        "key": "patch_flip",
        "type": "Bool"
      },
      {
        "description": "Allow patch 90 degree rotation.",
        "key": "patch_rotate",
        "type": "Bool"
      },
      {
        "description": "Allow patch tranposition.",
        "key": "patch_transpose",
        "type": "Bool"
      },
      {
        "description": "Decide on the size (with respect to the domain size) of the patches that will be used to create the new heightmap. This determines the level of detail and texture in the final result.",
        "key": "patch_width",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "QuiltingExpand.png"
  },
  "QuiltingShuffle": {
    "category": "Operator/Resynthesis",
    "description": "QuiltingShuffle performs a quilting procedure and generates a new image by seamlessly stitching together patches from an existing image.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Synthetized heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Smooth filter width with respect the overlap length.",
        "key": "filter_width_ratio",
        "type": "Float"
      },
      {
        "description": "Overlap ratio between patches.",
        "key": "overlap",
        "type": "Float"
      },
      {
        "description": "Allow patch flipping.",
        "key": "patch_flip",
        "type": "Bool"
      },
      {
        "description": "Allow patch 90 degree rotation.",
        "key": "patch_rotate",
        "type": "Bool"
      },
      {
        "description": "Allow patch tranposition.",
        "key": "patch_transpose",
        "type": "Bool"
      },
      {
        "description": "Decide on the size (with respect to the domain size) of the patches that will be used to create the new heightmap. This determines the level of detail and texture in the final result.",
        "key": "patch_width",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "QuiltingShuffle.png"
  },
  "RadialDisplacementToXy": {
    "category": "Math",
    "description": "RadialDisplacementToXy interprets the input array dr as a radial displacement and convert it to a pair of displacements dx and dy in cartesian coordinates.",
    "inputs": [
      {
        "caption": "dr",
        "description": "Radial displacement.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "dx",
        "description": "Displacement for  the x-direction.",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement for  the y-direction.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Center x coordinate.",
        "key": "center.x",
        "type": "Float"
      },
      {
        "description": "Center y coordinate.",
        "key": "center.y",
        "type": "Float"
      },
      {
        "description": "Smoothing parameter to avoid discontinuity at the origin.",
        "key": "smoothing",
        "type": "Float"
      }
    ],
    "snapshot": "RadialDisplacementToXy.png"
  },
  "RecastCliff": {
    "category": "Filter/Recast",
    "description": "RecastCliff add cliffs in a heightmap by introducing sharp changes in elevation to simulate steep vertical terrain features such as cliffs or escarpments.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Cliff amplitude.",
        "key": "amplitude",
        "type": "Float"
      },
      {
        "description": "Gain, influence the cliff elevation profile.",
        "key": "gain",
        "type": "Float"
      },
      {
        "description": "Filter influence radius.",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Reference talus at which the cliff are added.",
        "key": "talus_global",
        "type": "Float"
      }
    ],
    "snapshot": "RecastCliff.png"
  },
  "RecastSag": {
    "category": "Filter/Recast",
    "description": "RecastSag add cliffs in a heightmap by introducing sinks, droops, or bends downward changes in elevation.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Smoothing parameter.",
        "key": "k",
        "type": "Float"
      },
      {
        "description": "Reference elevation for the folding.",
        "key": "vref",
        "type": "Float"
      }
    ],
    "snapshot": "RecastSag.png"
  },
  "RecurveKura": {
    "category": "Filter/Recurve",
    "description": "RecurveKura is an operator based on the Kumaraswamy distribution that can be used to adjust the amplitude levels of a dataset.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Primarily controls the rightward skewness and tail behavior of the distribution.",
        "key": "a",
        "type": "Float"
      },
      {
        "description": "Primarily controls the leftward skewness and tail behavior.",
        "key": "b",
        "type": "Float"
      }
    ],
    "snapshot": "RecurveKura.png"
  },
  "RecurveS": {
    "category": "Filter/Recurve",
    "description": "RecurveS applied a curve adjustment filter using a smooth S-shape curve.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "RecurveS.png"
  },
  "RelativeElevation": {
    "category": "Features/Landform",
    "description": "RelativeElevation identifies heightmap relative elevation based on the surrounding heightmap values.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Relative elevation.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "RelativeElevation.png"
  },
  "Remap": {
    "category": "Filter/Range",
    "description": "The Remap operator is used to adjust the elevation values across the entire dataset, effectively changing the range of elevation data to match a desired output scale or to normalize the data.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Remapped heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Target range: define the new minimum and maximum values to remap the elevation values to.",
        "key": "remap",
        "type": "Value range"
      }
    ],
    "snapshot": "Remap.png"
  },
  "Rescale": {
    "category": "Filter/Range",
    "description": "The Rescale operator involves adjusting each data point by multiplying it with a predetermined constant.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Rescaled heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Determine whether a mean offset is applied to the values to center the scaling.",
        "key": "centered",
        "type": "Bool"
      },
      {
        "description": "Constant by which each elevation values will be multiplied.",
        "key": "scaling",
        "type": "Float"
      }
    ],
    "snapshot": "Rescale.png"
  },
  "ReverseMidpoint": {
    "category": "Primitive/Authoring",
    "description": "ReverseMidpoint generates an heightmap. It uses a polyline as a base, then recursively interpolate and displace midpoints to generate a terrain.",
    "inputs": [
      {
        "caption": "path",
        "description": "Set of points (x, y) and elevations z.",
        "type": "Path"
      }
    ],
    "outputs": [
      {
        "caption": "heightmap",
        "description": "Interpolated heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Added noise scaling.",
        "key": "noise_scale",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "ReverseMidpoint.png"
  },
  "Ridgelines": {
    "category": "Primitive/Authoring",
    "description": "Ridgelines generates an heightmap assuming the input path defines a ridgeline.",
    "inputs": [
      {
        "caption": "path",
        "description": "Set of points (x, y) and elevations z.",
        "type": "Path"
      },
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "heightmap",
        "description": "Interpolated heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Smoothing intensity.",
        "key": "k_smoothing",
        "type": "Float"
      },
      {
        "description": "Ridge slope.",
        "key": "talus_global",
        "type": "Float"
      },
      {
        "description": "Minimum value (lower values are clamped).",
        "key": "vmin",
        "type": "Float"
      },
      {
        "description": "Ridge edge width.",
        "key": "width",
        "type": "Float"
      }
    ],
    "snapshot": "Ridgelines.png"
  },
  "Rift": {
    "category": "Primitive/Function",
    "description": "Rift is function used to represent a conceptualized rift.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the width parameter.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Rift heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Angle.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Center x coordinate.",
        "key": "center.x",
        "type": "Float"
      },
      {
        "description": "Center y coordinate.",
        "key": "center.y",
        "type": "Float"
      },
      {
        "description": "Decide whether the rift bottom is sharp or not.",
        "key": "sharp_bottom",
        "type": "Bool"
      },
      {
        "description": "Rift slope.",
        "key": "slope",
        "type": "Float"
      },
      {
        "description": "Rift width.",
        "key": "width",
        "type": "Float"
      }
    ],
    "snapshot": "Rift.png"
  },
  "Rugosity": {
    "category": "Features",
    "description": "Rugosity identifies heightmap rugosity, i.e. the roughness or irregularity of the surface.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Rugosity.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Decides whether the rugosity values are clamped.",
        "key": "clamp_max",
        "type": "Bool"
      },
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Rugosity clamping upper bound.",
        "key": "vc_max",
        "type": "Float"
      }
    ],
    "snapshot": "Rugosity.png"
  },
  "Saturate": {
    "category": "Filter/Recurve",
    "description": "Saturate limits the amplitude of a signal to a predefined range while keeping the initial input range.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Saturated heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Smoothing intensity.",
        "key": "k_smoothing",
        "type": "Float"
      },
      {
        "description": "Saturation range: define the minimum and maximum values of the saturation process.",
        "key": "range",
        "type": "Value range"
      }
    ],
    "snapshot": "Saturate.png"
  },
  "ScanMask": {
    "category": "Mask/Adjust",
    "description": "ScanMask adjusts the brightness and contrast of an input mask.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Adjusted heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Brightness adjustment.",
        "key": "brightness",
        "type": "Float"
      },
      {
        "description": "Contrast adjustment.",
        "key": "contrast",
        "type": "Float"
      }
    ],
    "snapshot": "ScanMask.png"
  },
  "SelectAngle": {
    "category": "Mask/Selector",
    "description": "SelectAngle is a thresholding operator. It selects angle values within a specified range defined by the shape of a Gaussian pulse.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Mask heightmap (in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Selection center value.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Pre-filter radius.",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Selection half-width.",
        "key": "sigma",
        "type": "Float"
      }
    ],
    "snapshot": "SelectAngle.png"
  },
  "SelectBlobLog": {
    "category": "Mask/Selector",
    "description": "SelectBlobLog performs 'blob' detection using oa Laplacian of Gaussian (log) method. Blobs are areas in an image that are either brighter or darker than the surrounding areas.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Mask heightmap (in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Detection radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "SelectBlobLog.png"
  },
  "SelectCavities": {
    "category": "Mask/Selector",
    "description": "SelectCavities analyzes the curvature of an heightmap to identify concave or convex features such as valleys, depressions, ridges, or peaks.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Mask heightmap (in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Decides whether concave or convex features are detected.",
        "key": "concave",
        "type": "Bool"
      },
      {
        "description": "Detection radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "SelectCavities.png"
  },
  "SelectElevationSlope": {
    "category": "Mask/Selector",
    "description": "SelectElevationSlope select regions based a combinaison of elevation and slope values.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Mask heightmap (in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Gradient scaling, with respect to elevation.",
        "key": "gradient_scale",
        "type": "Float"
      }
    ],
    "snapshot": "SelectElevationSlope.png"
  },
  "SelectGt": {
    "category": "Mask/Selector",
    "description": "SelectGt is a thresholding operator. It transforms an input heightmap into a binary heightmap, where each pixel is assigned either a value of 0 or 1, depending on whether its intensity value surpasses a specified threshold value.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Mask heightmap (in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Selection value.",
        "key": "value",
        "type": "Float"
      }
    ],
    "snapshot": "SelectGt.png"
  },
  "SelectInterval": {
    "category": "Mask/Selector",
    "description": "SelectInterval is a thresholding operator. It transforms an input heightmap into a binary heightmap, where each pixel is assigned either a value of 0 or 1, depending on whether its intensity value is within an interval of values.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Mask heightmap (in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Selection value, lower bound.",
        "key": "value1",
        "type": "Float"
      },
      {
        "description": "Selection value, upper bound.",
        "key": "value2",
        "type": "Float"
      }
    ],
    "snapshot": "SelectInterval.png"
  },
  "SelectInwardOutward": {
    "category": "Mask/Selector",
    "description": "SelectInwardOutward returns values > 0.5 if the slope is pointing to the center (slope is inward), and values < 0.5 otherwise (slope is outward).",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Mask heightmap (in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Reference center x coordinate.",
        "key": "center.x",
        "type": "Float"
      },
      {
        "description": "Reference center y coordinate.",
        "key": "center.y",
        "type": "Float"
      }
    ],
    "snapshot": "SelectInwardOutward.png"
  },
  "SelectPulse": {
    "category": "Mask/Selector",
    "description": "SelectPulse is a thresholding operator. It selects values within a specified range defined by the shape of a Gaussian pulse.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Mask heightmap (in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Selection half-width.",
        "key": "sigma",
        "type": "Float"
      },
      {
        "description": "Selection center value.",
        "key": "value",
        "type": "Float"
      }
    ],
    "snapshot": "SelectPulse.png"
  },
  "SelectRivers": {
    "category": "Mask/Selector",
    "description": "SelectRivers is a thresholding operator. It creates a mask for river systems based on a flow accumulation threshold.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Mask heightmap (in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "SelectRivers.png"
  },
  "SelectTransitions": {
    "category": "Mask/Selector",
    "description": "SelectTransitions returns a mask filled with 1 at the blending transition between two heightmaps, and 0 elsewhere.",
    "inputs": [
      {
        "caption": "input 1",
        "description": "Input heightmap 1.",
        "type": "HeightMap"
      },
      {
        "caption": "input 2",
        "description": "Input heightmap 2.",
        "type": "HeightMap"
      },
      {
        "caption": "blend",
        "description": "Blended heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Mask heightmap (in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "SelectTransitions.png"
  },
  "SetAlpha": {
    "category": "Texture",
    "description": "SetAlpha adjusts the transparency of a texture based on an input alpha value, which can either be a single scalar or an array. When provided with a scalar alpha value, the function uniformly adjusts the transparency of the entire texture. Alternatively, when given an array of alpha values, it enables fine-grained control over the transparency of different parts of the texture, allowing for varied opacity across the texture's surface.",
    "inputs": [
      {
        "caption": "in",
        "description": "Input texture.",
        "type": "HeightMapRGBA"
      },
      {
        "caption": "alpha",
        "description": "Transparency (expected to be in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "out",
        "description": "Texture with new transparency.",
        "type": "HeightMapRGBA"
      }
    ],
    "parameters": [
      {
        "description": "Transparency as a scalar value (overriden if this alpha input is set).",
        "key": "alpha",
        "type": "Float"
      },
      {
        "description": "Clamp to [0, 1] to input alpha map.",
        "key": "clamp_alpha",
        "type": "Bool"
      }
    ],
    "snapshot": "SetAlpha.png"
  },
  "ShapeIndex": {
    "category": "Features/Landform",
    "description": "ShapeIndex is a measure used to quantify the shape complexity of landforms in an heightmap. It is calculated based on the second derivatives of the elevation surface. The surface index is greater than 0.5 for convex surface and lower than 0.5 for concave surface.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Shape index.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "ShapeIndex.png"
  },
  "SharpenCone": {
    "category": "Filter/Smoothing",
    "description": "SharpenCone is a cone kernel-based sharpen operator enhancing sharpness by emphasizing edges and fine details using a radial gradient shape.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Sharpening intensity.",
        "key": "scale",
        "type": "Float"
      }
    ],
    "snapshot": "SharpenCone.png"
  },
  "ShiftElevation": {
    "category": "Filter/Range",
    "description": "The ShiftElevation operator involves adjusting each data point by adding it with a predetermined constant.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Constant by which each elevation values will be added.",
        "key": "shift",
        "type": "Float"
      }
    ],
    "snapshot": "ShiftElevation.png"
  },
  "Slope": {
    "category": "Primitive/Function",
    "description": "Slope is function used to represent continuous terrain slope.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Slope heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Angle.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Center x coordinate.",
        "key": "center.x",
        "type": "Float"
      },
      {
        "description": "Center y coordinate.",
        "key": "center.y",
        "type": "Float"
      },
      {
        "description": "Slope slope...",
        "key": "talus_global",
        "type": "Float"
      }
    ],
    "snapshot": "Slope.png"
  },
  "SmoothCpulse": {
    "category": "Filter/Smoothing",
    "description": "Smoothing using a cubic pulse kernel can be considered somewhat similar to Gaussian smoothing. This technique is used to reduce noise and smooth data. The cubic pulse kernel has a cubic decrease in influence with distance within a finite interval. It is zero beyond a certain radius, providing a compact support that affects only nearby points.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "SmoothCpulse.png"
  },
  "SmoothFill": {
    "category": "Filter/Smoothing",
    "description": "SmoothFill is a smoothing technique that takes the maximum between the input and the filtered field to simulate a sediment deposition effect.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "depo. map",
        "description": "Deposition map.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Smoothing intensity of the maximum operator.",
        "key": "k",
        "type": "Float"
      },
      {
        "description": "Decides if the deposition map is normalized.",
        "key": "normalized_map",
        "type": "Bool"
      },
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "SmoothFill.png"
  },
  "SmoothFillHoles": {
    "category": "Filter/Smoothing",
    "description": "SmoothFillHoles is a smoothing technique that restricts smoothing effect to convex regions.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "SmoothFillHoles.png"
  },
  "SmoothFillSmearPeaks": {
    "category": "Filter/Smoothing",
    "description": "SmoothFillSmearPeaks is a smoothing technique that restricts smoothing effect to concave regions.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "SmoothFillSmearPeaks.png"
  },
  "Smoothstep3": {
    "category": "Math/Base",
    "description": "Apply a 3rd-order smoothstep function to every values.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "Smoothstep3.png"
  },
  "Smoothstep5": {
    "category": "Math/Base",
    "description": "Apply a 5th-order smoothstep function to every values.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "Smoothstep5.png"
  },
  "Stamping": {
    "category": "Primitive/Authoring",
    "description": "Stamping .",
    "inputs": [
      {
        "caption": "cloud",
        "description": "Stamping locations and intensities (as a Cloud).",
        "type": "Cloud"
      },
      {
        "caption": "kernel",
        "description": "Kernel to be stamped.",
        "type": "Kernel"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Output heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Blending method. Available values: add, maximum, minimum, multiply, substract.",
        "key": "blend_method",
        "type": "Enumeration"
      },
      {
        "description": "Smoothing parameter (if any).",
        "key": "k_smoothing",
        "type": "Float"
      },
      {
        "description": "Randomly flip, or not, the kernel before stamping (includes tranposing).",
        "key": "kernel_flip",
        "type": "Bool"
      },
      {
        "description": "Kernel base radius, with respect a unit square domain.",
        "key": "kernel_radius",
        "type": "Float"
      },
      {
        "description": "Randomly rotate, or not, the kernel before stamping (can be any rotation angle, can also be ressource consuming).",
        "key": "kernel_rotate",
        "type": "Bool"
      },
      {
        "description": "Determine whether the kernel amplitude is scaled with the point values.",
        "key": "kernel_scale_amplitude",
        "type": "Bool"
      },
      {
        "description": "Determine whether the kernel radius is scaled with the point values.",
        "key": "kernel_scale_radius",
        "type": "Bool"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "Stamping.png"
  },
  "Step": {
    "category": "Primitive/Function",
    "description": "Step is function used to represent a conceptualized escarpment, it serves as a tool for creating sharp, distinct changes in elevation.",
    "inputs": [
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "control",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Step heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Angle.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Center x coordinate.",
        "key": "center.x",
        "type": "Float"
      },
      {
        "description": "Center y coordinate.",
        "key": "center.y",
        "type": "Float"
      },
      {
        "description": "Step slope.",
        "key": "slope",
        "type": "Float"
      }
    ],
    "snapshot": "Step.png"
  },
  "Stratify": {
    "category": "Erosion/Stratify",
    "description": "Stratify adds horizontal stratifications to the input heightmap.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "noise",
        "description": "Local elevation noise, value range expected to be scaled with the one of the input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Eroded heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Reference value for the gamma correction applied to each strata, influence the cliff elevation profile.",
        "key": "gamma",
        "type": "Float"
      },
      {
        "description": "Noise range for the gamma value.",
        "key": "gamma_noise",
        "type": "Float"
      },
      {
        "description": "Numbner of strata.",
        "key": "n_strata",
        "type": "Integer"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Noise range for the strata elevations.",
        "key": "strata_noise",
        "type": "Float"
      }
    ],
    "snapshot": "Stratify.png"
  },
  "StratifyOblique": {
    "category": "Erosion/Stratify",
    "description": "StratifyOblique adds oblique stratifications to the input heightmap.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "noise",
        "description": "Local elevation noise, value range expected to be scaled with the one of the input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Eroded heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Angle in the horizontal plane.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Reference value for the gamma correction applied to each strata, influence the cliff elevation profile.",
        "key": "gamma",
        "type": "Float"
      },
      {
        "description": "Noise range for the gamma value.",
        "key": "gamma_noise",
        "type": "Float"
      },
      {
        "description": "Numbner of strata.",
        "key": "n_strata",
        "type": "Integer"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Noise range for the strata elevations.",
        "key": "strata_noise",
        "type": "Float"
      },
      {
        "description": "Step slope.",
        "key": "talus_global",
        "type": "Float"
      }
    ],
    "snapshot": "StratifyOblique.png"
  },
  "Thermal": {
    "category": "Erosion/Thermal",
    "description": "Thermal is an erosion operator used to simulate the process of thermal erosion, which is a type of erosion that occurs due to temperature fluctuations causing the breakdown and movement of soil and rock materials.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "bedrock",
        "description": "Bedrock elevation, erosion process cannot carve the heightmap further down this point.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Eroded heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "depo. map",
        "description": "Deposition map",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Number of iterations.",
        "key": "iterations",
        "type": "Integer"
      },
      {
        "description": "Repose slope.",
        "key": "talus_global",
        "type": "Float"
      }
    ],
    "snapshot": "Thermal.png"
  },
  "ThermalRib": {
    "category": "Erosion/Thermal",
    "description": "ThermalRib performs thermal erosion using a 'rib' algorithm (taken from Geomorph)",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "bedrock",
        "description": "Bedrock elevation, erosion process cannot carve the heightmap further down this point.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Eroded heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Number of iterations.",
        "key": "iterations",
        "type": "Integer"
      }
    ],
    "snapshot": "ThermalRib.png"
  },
  "Translate": {
    "category": "Operator/Transform",
    "description": "Translates an heightmap by a specified amount along the x and y axes. This function shifts the contents of the input array by `dx` and `dy` units along the x and y axes, respectively. It supports both periodic boundary conditions, where the array wraps around, and non-periodic conditions.",
    "inputs": [
      {
        "caption": "input",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Translate heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "The translation distance along the x-axis. Positive values shift the array to the right.",
        "key": "dx",
        "type": "Float"
      },
      {
        "description": "The translation distance along the y-axis. Positive values shift the array downward.",
        "key": "dy",
        "type": "Float"
      },
      {
        "description": "If set to `true`, the translation is periodic, meaning that elements that move out of one side of the array reappear on the opposite side.",
        "key": "periodic",
        "type": "Bool"
      }
    ],
    "snapshot": "Translate.png"
  },
  "Unpack": {
    "category": "Routing",
    "description": "KmeansClustering2 node groups the data into clusters based on the values of the two input features.",
    "inputs": [
      {
        "caption": "feature 1",
        "description": "First measurable property or characteristic of the data points being analyzed (e.g elevation, gradient norm, etc...",
        "type": "HeightMap"
      },
      {
        "caption": "feature 2",
        "description": "Second measurable property or characteristic of the data points being analyzed (e.g elevation, gradient norm, etc...",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Cluster labelling.",
        "type": "HeightMap"
      },
      {
        "caption": "scoring",
        "description": "Score in [0, 1] of the cell to belong to a given cluster",
        "type": "HeightMapVector"
      }
    ],
    "parameters": [
      {
        "description": "Determine whether scoring is computed.",
        "key": "compute_scoring",
        "type": "Bool"
      },
      {
        "description": "Number of clusters.",
        "key": "nclusters",
        "type": "Integer"
      },
      {
        "description": "Determine whether the feature amplitudes are normalized before the clustering.",
        "key": "normalize_inputs",
        "type": "Bool"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      },
      {
        "description": "Weight of the first feature.",
        "key": "weights.x",
        "type": "Float"
      },
      {
        "description": "Weight of the second feature.",
        "key": "weights.y",
        "type": "Float"
      }
    ],
    "snapshot": "Unpack.png"
  },
  "Unsphericity": {
    "category": "Features/Landform",
    "description": "Unsphericity is a measure used to quantify the deviation of the heightmap shape from a perfect sphere. In other words, it indicates how much the terrain differs from being perfectly round or spherical.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Shape index.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "Unsphericity.png"
  },
  "ValleyWidth": {
    "category": "Features/Landform",
    "description": "ValleyWidth identifies valley lines and measure the width of the valley at each cross-section.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Valley width heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Filter radius with respect to the domain size.",
        "key": "radius",
        "type": "Float"
      }
    ],
    "snapshot": "ValleyWidth.png"
  },
  "Warp": {
    "category": "Operator/Transform",
    "description": "The Warp node transforms a base heightmap by warping/pushing pixels as defined by the input displacements.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Warped heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [],
    "snapshot": "Warp.png"
  },
  "WarpDownslope": {
    "category": "Operator/Transform",
    "description": "Warp the heightmap with a direction and amount based on the local downslope.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "mask",
        "description": "Mask defining the filtering intensity (expected in [0, 1]).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Warp scaling with respect to the gradient.",
        "key": "amount",
        "type": "Float"
      },
      {
        "description": "Prefiltering radius for gradient computation.",
        "key": "radius",
        "type": "Float"
      },
      {
        "description": "Reverse warping direction (upslope if true and downslope otherwise).",
        "key": "reverse",
        "type": "Bool"
      }
    ],
    "snapshot": "WarpDownslope.png"
  },
  "WaveDune": {
    "category": "Primitive/Function",
    "description": "WaveDune mimics using a periodic function the formation and spatial distribution of transverse sand dunes on a terrain.",
    "inputs": [
      {
        "caption": "dr",
        "description": "Displacement with respect to the domain size (normal direction).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "WaveDune heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Angle in the horizontal plane.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Float"
      },
      {
        "description": "Phase shift.",
        "key": "phase_shift",
        "type": "Float"
      },
      {
        "description": "Relative position of the dune bottom, in [0, 1].",
        "key": "xbottom",
        "type": "Float"
      },
      {
        "description": "Relative position of the dune top, in [0, 1].",
        "key": "xtop",
        "type": "Float"
      }
    ],
    "snapshot": "WaveDune.png"
  },
  "WaveSine": {
    "category": "Primitive/Function",
    "description": "WaveSine generates sine waves.",
    "inputs": [
      {
        "caption": "dr",
        "description": "Displacement with respect to the domain size (normal direction).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "WaveSine heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Angle in the horizontal plane.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Float"
      },
      {
        "description": "Phase shift.",
        "key": "phase_shift",
        "type": "Float"
      }
    ],
    "snapshot": "WaveSine.png"
  },
  "WaveSquare": {
    "category": "Primitive/Function",
    "description": "WaveSquare generates square waves.",
    "inputs": [
      {
        "caption": "dr",
        "description": "Displacement with respect to the domain size (normal direction).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "WaveSquare heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Angle in the horizontal plane.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Float"
      },
      {
        "description": "Phase shift.",
        "key": "phase_shift",
        "type": "Float"
      }
    ],
    "snapshot": "WaveSquare.png"
  },
  "WaveTriangular": {
    "category": "Primitive/Function",
    "description": "WaveTriangular generates triangular waves.",
    "inputs": [
      {
        "caption": "dr",
        "description": "Displacement with respect to the domain size (normal direction).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "WaveTriangular heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Angle in the horizontal plane.",
        "key": "angle",
        "type": "Float"
      },
      {
        "description": "Noise wavenumbers (kx, ky) for each directions.",
        "key": "kw",
        "type": "Float"
      },
      {
        "description": "Phase shift.",
        "key": "phase_shift",
        "type": "Float"
      },
      {
        "description": "Decides on wave asymmetry, expected in [0, 1].",
        "key": "slant_ratio",
        "type": "Float"
      }
    ],
    "snapshot": "WaveTriangular.png"
  },
  "White": {
    "category": "Primitive/Random",
    "description": "White noise operator generates a random signal with a flat power spectral density.",
    "inputs": [
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "White.png"
  },
  "WhiteDensityMap": {
    "category": "Primitive/Random",
    "description": "WhiteDensityMap noise operator generates a random signal with a flat power and a spatial density defined by an input heightmap.",
    "inputs": [
      {
        "caption": "density",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "WhiteDensityMap.png"
  },
  "WhiteSparse": {
    "category": "Primitive/Random",
    "description": "WhiteSparse noise operator generates a random signal with a flat power spectral density, but with a sparse spatial density.",
    "inputs": [
      {
        "caption": "envelope",
        "description": "Output noise amplitude envelope.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Generated noise.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Noise density.",
        "key": "density",
        "type": "Float"
      },
      {
        "description": "Random seed number.",
        "key": "seed",
        "type": "Random seed"
      }
    ],
    "snapshot": "WhiteSparse.png"
  },
  "ZeroedEdges": {
    "category": "Math/Boundaries",
    "description": "ZeroedEdges is an operator that enforces values close to zero at the domain edges.",
    "inputs": [
      {
        "caption": "input",
        "description": "Input heightmap.",
        "type": "HeightMap"
      },
      {
        "caption": "dr",
        "description": "Displacement with respect to the domain size (radial direction).",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Filtered heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Measure used for the distance calculation. Available values: Chebyshev, Euclidian, Euclidian/Chebyshev, Manhattan.",
        "key": "distance_function",
        "type": "Enumeration"
      },
      {
        "description": "Shape power law.",
        "key": "sigma",
        "type": "Float"
      }
    ],
    "snapshot": "ZeroedEdges.png"
  },
  "Zoom": {
    "category": "Operator/Transform",
    "description": "Applies a zoom effect to an heightmap with an adjustable center. This function scales the input 2D array by a specified zoom factor, effectively resizing the array's contents. The zoom operation is centered around a specified point within the array, allowing for flexible zooming behavior.",
    "inputs": [
      {
        "caption": "input",
        "description": "Displacement with respect to the domain size (x-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dx",
        "description": "Displacement with respect to the domain size (y-direction).",
        "type": "HeightMap"
      },
      {
        "caption": "dy",
        "description": "Control parameter, acts as a multiplier for the weight parameter.",
        "type": "HeightMap"
      }
    ],
    "outputs": [
      {
        "caption": "output",
        "description": "Zoom heightmap.",
        "type": "HeightMap"
      }
    ],
    "parameters": [
      {
        "description": "Center of the zoom operation.",
        "key": "center.x",
        "type": "Float"
      },
      {
        "description": "Center of the zoom operation.",
        "key": "center.y",
        "type": "Float"
      },
      {
        "description": "If set to `true`, the zoom is periodic.",
        "key": "periodic",
        "type": "Bool"
      },
      {
        "description": "The factor by which to zoom the heightmap.",
        "key": "zoom_factor",
        "type": "Float"
      }
    ],
    "snapshot": "Zoom.png"
  }
}
